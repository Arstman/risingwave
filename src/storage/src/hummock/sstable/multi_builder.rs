// Copyright 2022 Singularity Data
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use futures::Future;
use risingwave_hummock_sdk::key::{Epoch, FullKey};
use risingwave_hummock_sdk::HummockSSTableId;
use risingwave_pb::hummock::VNodeBitmap;

use crate::hummock::value::HummockValue;
use crate::hummock::{HummockResult, SSTableBuilder, Sstable};

/// A wrapper for [`SSTableBuilder`] which automatically split key-value pairs into multiple tables,
/// based on their target capacity set in options.
///
/// When building is finished, one may call `finish` to get the results of zero, one or more tables.
pub struct CapacitySplitTableBuilder<B> {
    /// When creating a new [`SSTableBuilder`], caller use this closure to specify the id and
    /// options.
    get_id_and_builder: B,

    finished_ssts: Vec<(Sstable, Vec<VNodeBitmap>)>,

    current_builder: Option<(HummockSSTableId, SSTableBuilder)>,
}

impl<B, F> CapacitySplitTableBuilder<B>
where
    B: Fn() -> F,
    F: Future<Output = HummockResult<(u64, SSTableBuilder)>>,
{
    /// Creates a new [`CapacitySplitTableBuilder`] using given configuration generator.
    pub fn new(get_id_and_builder: B) -> Self {
        Self {
            get_id_and_builder,
            finished_ssts: Vec::new(),
            current_builder: None,
        }
    }

    /// Returns the number of [`SSTableBuilder`]s.
    pub fn len(&self) -> usize {
        self.finished_ssts.len() + if self.current_builder.is_some() { 1 } else { 0 }
    }

    /// Returns true if no builder is created.
    pub fn is_empty(&self) -> bool {
        self.finished_ssts.is_empty() && self.current_builder.is_none()
    }

    /// Adds a user key-value pair to the underlying builders, with given `epoch`.
    ///
    /// If the current builder reaches its capacity, this function will create a new one with the
    /// configuration generated by the closure provided earlier.
    pub async fn add_user_key(
        &mut self,
        user_key: Vec<u8>,
        value: HummockValue<&[u8]>,
        epoch: Epoch,
    ) -> HummockResult<()> {
        assert!(!user_key.is_empty());
        let full_key = FullKey::from_user_key(user_key, epoch);
        self.add_full_key(full_key.as_slice(), value, true).await?;
        Ok(())
    }

    /// Adds a key-value pair to the underlying builders.
    ///
    /// If `allow_split` and the current builder reaches its capacity, this function will create a
    /// new one with the configuration generated by the closure provided earlier.
    ///
    /// Note that in some cases like compaction of the same user key, automatic splitting is not
    /// allowed, where `allow_split` should be `false`.
    pub async fn add_full_key(
        &mut self,
        full_key: FullKey<&[u8]>,
        value: HummockValue<&[u8]>,
        allow_split: bool,
    ) -> HummockResult<()> {
        // Seal current builder if it reaches capacity and allow split
        if self.current_builder.is_some()
            && allow_split
            && self.current_builder.as_mut().unwrap().1.reach_capacity()
        {
            let (table_id, current_builder) = self.current_builder.take().unwrap();
            let (meta, vnode_bitmap) = current_builder.finish().await?;
            self.finished_ssts
                .push((Sstable { id: table_id, meta }, vnode_bitmap));
        }

        // Initialize a new builder if there is no current builder
        let builder = if self.current_builder.is_none() {
            let (id, builder) = (self.get_id_and_builder)().await?;
            &mut self.current_builder.insert((id, builder)).1
        } else {
            &mut self.current_builder.as_mut().unwrap().1
        };

        builder.add(full_key.into_inner(), value).await?;
        Ok(())
    }

    /// Marks the current builder as sealed. Next call of `add` will always create a new table.
    ///
    /// If there's no builder created, or current one is already sealed before, then this function
    /// will be no-op.
    pub async fn seal_current(&mut self) -> HummockResult<()> {
        if let Some((id, builder)) = self.current_builder.take() {
            let (meta, vnode_bitmap) = builder.finish().await?;
            self.finished_ssts
                .push((Sstable { id, meta }, vnode_bitmap));
        }
        Ok(())
    }

    /// Finalizes all the tables to be ids and sstable builder output
    pub async fn finish(mut self) -> HummockResult<Vec<(Sstable, Vec<VNodeBitmap>)>> {
        self.seal_current().await?;
        Ok(self.finished_ssts)
    }
}

#[cfg(test)]
mod tests {
    use std::sync::atomic::AtomicU64;
    use std::sync::atomic::Ordering::SeqCst;

    use futures::executor::block_on;
    use itertools::Itertools;

    use super::*;
    use crate::hummock::iterator::test_utils::mock_sstable_store;
    use crate::hummock::sstable::utils::CompressionAlgorithm;
    use crate::hummock::test_utils::default_builder_opt_for_test;
    use crate::hummock::{SSTableBuilderOptions, WriteCachePolicy, DEFAULT_RESTART_INTERVAL};

    #[tokio::test]
    async fn test_empty() {
        let next_id = AtomicU64::new(1001);
        let block_size = 1 << 10;
        let table_capacity = 4 * block_size;
        let sstable_store = mock_sstable_store();
        let get_id_and_builder = move || {
            let sst_id = next_id.fetch_add(1, SeqCst);
            let sstable_store = sstable_store.clone();
            async move {
                Ok((
                    sst_id,
                    SSTableBuilder::new(
                        SSTableBuilderOptions {
                            capacity: table_capacity,
                            block_capacity: block_size,
                            restart_interval: DEFAULT_RESTART_INTERVAL,
                            bloom_false_positive: 0.1,
                            compression_algorithm: CompressionAlgorithm::None,
                        },
                        sstable_store
                            .new_sstable_writer(sst_id, WriteCachePolicy::Disable)
                            .await
                            .unwrap(),
                    ),
                ))
            }
        };
        let builder = CapacitySplitTableBuilder::new(get_id_and_builder);
        let results = block_on(builder.finish()).unwrap();
        assert!(results.is_empty());
    }

    #[tokio::test]
    async fn test_lots_of_tables() {
        let next_id = AtomicU64::new(1001);
        let block_size = 1 << 10;
        let table_capacity = 4 * block_size;
        let sstable_store = mock_sstable_store();
        let get_id_and_builder = move || {
            let sst_id = next_id.fetch_add(1, SeqCst);
            let sstable_store = sstable_store.clone();
            async move {
                Ok((
                    sst_id,
                    SSTableBuilder::new(
                        SSTableBuilderOptions {
                            capacity: table_capacity,
                            block_capacity: block_size,
                            restart_interval: DEFAULT_RESTART_INTERVAL,
                            bloom_false_positive: 0.1,
                            compression_algorithm: CompressionAlgorithm::None,
                        },
                        sstable_store
                            .new_sstable_writer(sst_id, WriteCachePolicy::Disable)
                            .await
                            .unwrap(),
                    ),
                ))
            }
        };
        let mut builder = CapacitySplitTableBuilder::new(get_id_and_builder);

        for i in 0..table_capacity {
            builder
                .add_user_key(
                    b"key".to_vec(),
                    HummockValue::put(b"value"),
                    (table_capacity - i) as u64,
                )
                .await
                .unwrap();
        }

        let results = block_on(builder.finish()).unwrap();
        assert!(results.len() > 1);
        assert_eq!(
            results.iter().map(|(sst, _)| sst.id).duplicates().count(),
            0
        );
    }

    #[tokio::test]
    async fn test_table_seal() {
        let opt = default_builder_opt_for_test();
        let next_id = AtomicU64::new(1001);
        let sstable_store = mock_sstable_store();
        let mut builder = CapacitySplitTableBuilder::new(move || {
            let sst_id = next_id.fetch_add(1, SeqCst);
            let opt = opt.clone();
            let sstable_store = sstable_store.clone();
            async move {
                Ok((
                    sst_id,
                    SSTableBuilder::new(
                        opt,
                        sstable_store
                            .new_sstable_writer(sst_id, WriteCachePolicy::Disable)
                            .await
                            .unwrap(),
                    ),
                ))
            }
        });
        let mut epoch = 100;

        macro_rules! add {
            () => {
                epoch -= 1;
                builder
                    .add_user_key(b"k".to_vec(), HummockValue::put(b"v"), epoch)
                    .await
                    .unwrap();
            };
        }

        assert_eq!(builder.len(), 0);
        builder.seal_current().await.unwrap();
        assert_eq!(builder.len(), 0);
        add!();
        assert_eq!(builder.len(), 1);
        add!();
        assert_eq!(builder.len(), 1);
        builder.seal_current().await.unwrap();
        assert_eq!(builder.len(), 1);
        add!();
        assert_eq!(builder.len(), 2);
        builder.seal_current().await.unwrap();
        assert_eq!(builder.len(), 2);
        builder.seal_current().await.unwrap();
        assert_eq!(builder.len(), 2);

        let results = builder.finish().await.unwrap();
        assert_eq!(results.len(), 2);
    }

    #[tokio::test]
    async fn test_initial_not_allowed_split() {
        let opt = default_builder_opt_for_test();
        let next_id = AtomicU64::new(1001);
        let sstable_store = mock_sstable_store();
        let mut builder = CapacitySplitTableBuilder::new(move || {
            let opt = opt.clone();
            let sst_id = next_id.fetch_add(1, SeqCst);
            let sstable_store = sstable_store.clone();
            async move {
                Ok((
                    sst_id,
                    SSTableBuilder::new(
                        opt,
                        sstable_store
                            .new_sstable_writer(sst_id, WriteCachePolicy::Disable)
                            .await
                            .unwrap(),
                    ),
                ))
            }
        });

        builder
            .add_full_key(
                FullKey::from_user_key_slice(b"k", 233).as_slice(),
                HummockValue::put(b"v"),
                false,
            )
            .await
            .unwrap();
    }
}
